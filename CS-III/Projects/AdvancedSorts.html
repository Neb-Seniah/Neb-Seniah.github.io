
<!doctype html>                                                                                                                                                                                                                                      
<html lang="en">                                                                                                                                                                                                                                     
  <meta http-equiv="Content-Type"                                                                                                                                                                                                                    
        content="text/html; charset=utf-8">                                                                                                                                                                                                          
  <title> Advanced Sort Algorithms - Ben Haines</title></head>
<link rel="stylesheet" href="../../site.css">                                                                                                                                                                                                       
<body>
  <h2>Sorting Algorithms</h2>
  <p>A sorting algorithm takes a selection of numbers or words, which are called elements, in a group, which is an array. Sorting algorithms sort an array so that all of their elements are in a certain elements, when learning about different algorithms, the goal will be to sort an array of integers, which are whole numbers, into acending order. When deciding on what sort to use for a situation in the real world, the two most important factors to consider are how long it would take to finish in the worst case, as well how much space it consumes while running. Simple sorting algorithms like bubble sort or selection sort will usually take a while, but more complex sorting algoritms will take less time but be harder to impliment. Time complexity is how long it takes for a program to finish running, while space complexity is how much space it takes up. </p><br>
  <h2>Merge Sort</h2>
  <p> Merge sort works by splitting an unsorted array in half until it makes seperates all single elements into smaller sub-arrays. Then it will slowly combine them back together while sorting them, until they form into a fully sorted array, if the number of elements is not a power of two, then some elements will get sorted at different times. <br><br>For example, an array of six will split into two sub-arrays of three, then each sub-array will split into groups of two and one, the two sub-arrays of two elements will split again, creating six sub-arrays of individual elements.<br> [6, 5, 4, 3, 2, 1] -> [6, 5, 4] & [3, 2, 1] -> [6, 5] & [4], & [3, 2] & [1] -> [6] & [5] & [4] & [3] & [2] & [1] <br><br>Then the 6 sub-arrays begin reforming in the order they were split, as well as being sorted.<br> [6] & [5] & [4] & [3] & [2] & [1] -> [5, 6] & [4], & [2, 3] & [1] -> [4, 5, 6] & [1, 2, 3] -> [1, 2, 3, 4, 5, 6]</p><br>
  <h2>Quicksort</h2>
  <p> Quicksort chooses pivots to sort by creating sub-arrays and fusing them all back together, it is a more efficent version of Merge Sort space-wise, but sometimes will be worse time-wise. The first step of Quicksort is to choose a pivot in an array of elements, the specific element does not matter. <br> [2, 6, 5, [3], 1, 4] <br> After selecting a pivot, the next step is to rearrange array elements so values less than the pivot are on the left, and greater values on the right. The pivot will now be in the correct space in the array.<br> [2, 1, [3], 4, 6, 5] <br> Now use quicksort on the left and right sides of the pivot until there is only one element in the recursion array. As the arrays reach one element remaining, they reconvine to form a sorted array. <br> [2, 1] -> [2, [1]] -> [[1], 2] & [[4], 6, 5] -> [[4], 6, 5] -> [6, 5] -> [[6], 5] -> [5, [6]] = [1] + [2] + [3] + [4] + [5] + [6] -> [1, 2, 3, 4, 5, 6] <br> The array sorts in order because when using recursion, the left array is called first, recursively using the function of the right array would cause it to be placed in reverse order.</p><br>
  <h2>Heapsort</h2>
  <p> Heapsort is by far one of the most complex sorts, and in order to properly understand Heapsort, there needs to be an understanding of binary trees. Binary trees are a collection of elements that have two other elements steming off of them, and the element at the top is called the root. An array of the values [4, 5, 3, 9, 2, 11] could have a binary tree where 4 is the root, 5 and 3 branches off of 4, 9 and 2 with 5, and 11 on 3. When performing the actual sort, the step after constructing the binary tree would to max heap the tree, which means the parent always has to be greater than or equal to its branches, this is achived by swapping certain elements, the tree from before could end up having 11 as the root, 9 and 5 as branches, 4 and 3 branching off of 9, and 2 off of 5, as there are multiple possible variations, such as having 3 being a branch of 5 and 2 a branch of 9. Then the root element is removed from the binary tree and added to the end of the sorted array, a random branch with no branches itself will replace the root, then just repeat the heapify and replacement of the root until the array is sorted. When adding the root to the end of the array, it should be noted it will be the last place without a value, not the very end of the array, as that would sort it the opposite way.
  </p><br>
  <br>
  <h2>Time Complexity</h2>
  <p>
    &nbsp;&nbsp;&nbsp;&nbsp;<h4>Merge Sort</h4> - O(n * log(n)) - The time that Merge Sort takes is always the same, it will always split and resort arrays, even if it is already in the right order.
    <br>&nbsp;&nbsp;&nbsp;&nbsp;<h4>Quicksort</h4> - O(n * log(n)) - While Quicksort usually takes as much time as Merge Sort and Heapsort, it's time complexity can be up to O(n^2) if the pivot selected happens to be the largest or smallest element, or if all elements have the same value.
    <br>&nbsp;&nbsp;&nbsp;&nbsp;<h4>Heapsort</h4> - O(n * log(n)) - Takes the same amount of time that Merge Sort does and Quicksort usually does, also does the same thing regardless of what the elements' values are. 
  </p><br>
  <h2>Space Complexity</h2>
  <p>
    &nbsp;&nbsp;&nbsp;&nbsp;<h4>Merge Sort</h4> - O(n) - Because of how many times Merge Sort recursively calls itself, it takes up the most space to use, since it calls itself for every element, it takes up as much space as there are elements in the array.
    <br>&nbsp;&nbsp;&nbsp;&nbsp;<h4>Quicksort</h4> - O(log(n)) - Quicksort calls itself n times, however every array created will have less elements because they lack the pivot when they split, unlike Merge Sort. 
    <br>&nbsp;&nbsp;&nbsp;&nbsp;<h4>Heapsort</h4> - O(1) - Heapsort does not recursively call itself, so it's space complexity is the lowest possible.
  </p>
</body>
</html>
